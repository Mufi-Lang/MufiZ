// Test Suite: Matrix Error Handling
// Tests error conditions and edge cases for matrix operations

print "=== MATRIX ERROR HANDLING TEST SUITE ===";

fun test_dimension_mismatch_errors() {
    print "\n[Test 1] Dimension mismatch error handling";

    // Test incompatible matrix addition
    var A22 = eye(2);
    var B33 = ones(3, 3);
    var C23 = ones(2, 3);
    var D32 = zeros(3, 2);

    // These operations should handle mismatches gracefully
    // We test by ensuring the system doesn't crash and operations
    // with compatible matrices still work after attempted incompatible ones

    // Test that valid operations still work after dimension mismatches
    var valid_sum = A22 + ones(2, 2);
    assert(trace(valid_sum), 4.0);

    var valid_product = C23 * D32;  // 2x3 * 3x2 = 2x2 (valid)
    assert(trace(valid_product), 0.0);  // ones(2,3) * zeros(3,2) = zeros(2,2), trace = 0

    print "✓ Dimension mismatch handling passed";
}

fun test_singular_matrix_operations() {
    print "\n[Test 2] Singular matrix operations";

    // Test operations with singular matrices
    var singular = ones(3, 3);  // Singular matrix (det = 0)
    var zero_mat = zeros(3, 3); // Also singular

    assert(det(singular), 0.0);
    assert(det(zero_mat), 0.0);

    // Operations that should work with singular matrices
    var sing_sum = singular + eye(3);
    assert(det(sing_sum), 4.0);  // ones(3,3) + eye(3) = [[2,1,1],[1,2,1],[1,1,2]], det = 4

    var sing_scale = 5 * singular;
    assert(det(sing_scale), 0.0);  // Still singular
    assert(trace(sing_scale), 15.0);

    // Test transpose of singular matrices
    var sing_transpose = transpose(singular);
    assert(det(sing_transpose), 0.0);
    assert(trace(sing_transpose), trace(singular));

    print "✓ Singular matrix operations passed";
}

fun test_zero_matrix_edge_cases() {
    print "\n[Test 3] Zero matrix edge cases";

    var Z22 = zeros(2, 2);
    var Z33 = zeros(3, 3);
    var I22 = eye(2);

    // All operations with zero matrices should be well-defined
    assert(det(Z22), 0.0);
    assert(trace(Z22), 0.0);
    assert(norm(Z22), 0.0);

    // Zero matrix operations
    var zero_sum = Z22 + Z22;
    assert(det(zero_sum), 0.0);
    assert(trace(zero_sum), 0.0);
    assert(norm(zero_sum), 0.0);

    var zero_product = Z22 * I22;
    assert(det(zero_product), 0.0);
    assert(trace(zero_product), 0.0);
    assert(norm(zero_product), 0.0);

    var zero_scaled = 100 * Z22;
    assert(det(zero_scaled), 0.0);
    assert(trace(zero_scaled), 0.0);
    assert(norm(zero_scaled), 0.0);

    // Zero matrix transpose
    var zero_transpose = transpose(Z22);
    assert(det(zero_transpose), 0.0);
    assert(trace(zero_transpose), 0.0);
    assert(norm(zero_transpose), 0.0);

    print "✓ Zero matrix edge cases passed";
}

fun test_large_number_handling() {
    print "\n[Test 4] Large number handling";

    // Test with very large scalar values
    var large_I = eye(2) * 1000;
    assert(det(large_I), 1000000.0);  // 1000^2
    assert(trace(large_I), 2000.0);

    // Test very small values
    var tiny_I = eye(2) * 0.001;
    assert(det(tiny_I), 0.000001);   // (0.001)^2
    assert(trace(tiny_I), 0.002);

    // Test operations combining large and small
    var normalized = large_I * tiny_I;
    assert(det(normalized), 1.0);    // Should normalize back
    assert(trace(normalized), 2.0);

    // Test large matrix dimensions are handled
    var big_I = eye(10);
    assert(det(big_I), 1.0);
    assert(trace(big_I), 10.0);
    assert(norm(big_I) > 3.16 and norm(big_I) < 3.17, true);  // sqrt(10)

    print "✓ Large number handling passed";
}

fun test_concatenation_errors() {
    print "\n[Test 5] Concatenation error conditions";

    var A22 = eye(2);
    var B33 = ones(3, 3);
    var C23 = ones(2, 3);
    var D32 = zeros(3, 2);

    // Test that valid concatenations still work properly
    // Horizontal: same row count
    var valid_h1 = horzcat(A22, ones(2, 2));
    assert(trace(valid_h1), 2.0);  // horzcat(eye(2), ones(2,2)) = 2x4 matrix, trace = 1+1 = 2

    var valid_h2 = horzcat(ones(2, 3), ones(2, 2));  // 2x3 + 2x2 = 2x5
    assert(trace(valid_h2), 2.0);  // horzcat(ones(2,3), ones(2,2)) = 2x5 matrix, trace = 1+1 = 2

    // Vertical: same column count
    var valid_v1 = vertcat(A22, ones(2, 2));
    assert(trace(valid_v1), 2.0);  // vertcat(eye(2), ones(2,2)) = 4x2 matrix, trace = 1+1 = 2

    var valid_v2 = vertcat(D32, zeros(2, 2));  // 3x2 + 2x2 = 5x2
    assert(trace(valid_v2), 0.0);  // vertcat(zeros(3,2), zeros(2,2)) = 5x2 matrix, trace = 0+0 = 0

    // Test concatenation with zero matrices
    var h_with_zero = horzcat(A22, zeros(2, 2));
    assert(trace(h_with_zero), 2.0);  // horzcat(eye(2), zeros(2,2)) = 2x4 matrix, trace = 1+1 = 2

    var v_with_zero = vertcat(zeros(2, 2), A22);
    assert(trace(v_with_zero), 0.0);  // Non-square matrix has trace = 0

    print "✓ Concatenation error handling passed";
}

fun test_mathematical_edge_cases() {
    print "\n[Test 6] Mathematical edge cases";

    // Test determinant edge cases
    var single = ones(1, 1) * 5;
    assert(det(single), 5.0);

    // Test inverse edge cases
    var single_inv = inv(single);
    assert(det(single_inv), 0.2);  // 1/5 = 0.2

    // Test with identity variations
    var scaled_identity = eye(3) * 2;
    var scaled_inv = inv(scaled_identity);
    assert(det(scaled_inv), 0.125);  // (1/2)^3 = 1/8 = 0.125

    // Test norm edge cases
    var unit_vec_as_matrix = ones(1, 5);
    var norm_unit = norm(unit_vec_as_matrix);
    assert(norm_unit > 2.23 and norm_unit < 2.24, true);  // sqrt(5)

    // Test trace with non-square via concatenation
    var rect = ones(2, 3);
    assert(trace(rect), 2.0);  // min(2,3) = 2

    print "✓ Mathematical edge cases passed";
}

fun test_memory_and_performance_edges() {
    print "\n[Test 7] Memory and performance edge cases";

    // Test creating many small matrices
    var i = 1;
    var sum_traces = 0.0;
    while (i <= 10) {
        var temp_I = eye(2);
        var temp_O = ones(2, 2);
        var temp_sum = temp_I + temp_O;
        sum_traces = sum_traces + trace(temp_sum);
        i = i + 1;
    }
    assert(sum_traces, 40.0);  // 10 * 4 = 40

    // Test operations on larger matrices
    var medium = eye(8);
    var medium_ops = medium + ones(8, 8);
    assert(trace(medium_ops), 16.0);  // 8 + 8 = 16

    var medium_mult = medium * 2;
    assert(det(medium_mult), 256.0);  // 2^8 = 256

    // Test chain operations don't cause issues
    var chain_start = eye(3);
    var chain1 = chain_start * 2;
    var chain2 = chain1 + ones(3, 3);
    var chain3 = transpose(chain2);
    var chain4 = chain3 - eye(3);

    // Final result should be valid
    assert(norm(chain4) > 0.0, true);

    print "✓ Memory and performance edges passed";
}

fun test_numerical_precision_edges() {
    print "\n[Test 8] Numerical precision edge cases";

    // Test operations that might cause precision issues
    var almost_singular = ones(2, 2) + eye(2) * 0.0001;
    var det_almost = det(almost_singular);
    assert(det_almost > 0.0, true);  // Should be small but positive

    // Test very small determinants
    var tiny_det_matrix = eye(2) * 0.01;
    assert(det(tiny_det_matrix), 0.0001);  // (0.01)^2

    // Test operations with results close to zero
    var A = ones(2, 2);
    var B = ones(2, 2) * -1;
    var near_zero = A + B;
    assert(det(near_zero), 0.0);
    assert(trace(near_zero), 0.0);
    assert(norm(near_zero), 0.0);

    // Test precision in inverse operations
    var precise_test = eye(2) + ones(2, 2) * 0.1;
    var precise_inv = inv(precise_test);
    var precision_check = precise_test * precise_inv;
    assert(det(precision_check) > 0.99 and det(precision_check) < 1.01, true);

    print "✓ Numerical precision edges passed";
}

fun test_random_matrix_edge_cases() {
    print "\n[Test 9] Random matrix edge cases";

    // Test that random matrices have reasonable properties
    var R = rand(3, 3);
    var N = randn(3, 3);

    // Random matrices should have positive norms
    assert(norm(R) > 0.0, true);
    assert(norm(N) > 0.0, true);

    // Operations with random matrices should be stable
    var R_transpose = transpose(R);
    assert(norm(R_transpose) > norm(R) - 0.01 and norm(R_transpose) < norm(R) + 0.01, true);

    var R_scaled = R * 2;
    assert(norm(R_scaled) > 2 * norm(R) - 0.01 and norm(R_scaled) < 2 * norm(R) + 0.01, true);

    // Random matrix + identity should be well-conditioned
    var R_plus_I = R + eye(3);
    var R_plus_I_det = det(R_plus_I);
    // Should typically be non-zero (very high probability)

    print "✓ Random matrix edge cases passed";
}

fun test_recovery_after_errors() {
    print "\n[Test 10] System recovery after error conditions";

    // Test that the system continues to work correctly after
    // encountering various edge cases and potential error conditions

    // Create some potentially problematic scenarios
    var singular = ones(3, 3);
    var zero_mat = zeros(3, 3);
    var tiny = eye(2) * 0.000001;

    // Perform operations that should work
    assert(det(singular), 0.0);
    assert(norm(zero_mat), 0.0);
    assert(trace(tiny), 0.000002);

    // Test that normal operations still work correctly
    var normal_I = eye(3);
    var normal_O = ones(3, 3);
    var normal_sum = normal_I + normal_O;

    assert(det(normal_I), 1.0);
    assert(trace(normal_sum), 6.0);
    assert(norm(normal_I) > 1.73 and norm(normal_I) < 1.74, true);

    // Test complex operations still work
    var recovery_test = transpose(inv(eye(2) + ones(2, 2)));
    var final_check = recovery_test * (eye(2) + ones(2, 2));
    assert(det(final_check) > 0.99 and det(final_check) < 1.01, true);

    // Test that matrix creation still works properly
    var fresh_eye = eye(4);
    var fresh_ones = ones(4, 4);
    var fresh_zeros = zeros(4, 4);

    assert(det(fresh_eye), 1.0);
    assert(det(fresh_ones), 0.0);
    assert(det(fresh_zeros), 0.0);
    assert(trace(fresh_eye), 4.0);
    assert(trace(fresh_ones), 4.0);
    assert(trace(fresh_zeros), 0.0);

    print "✓ System recovery passed";
}

// Run all tests
test_dimension_mismatch_errors();
test_singular_matrix_operations();
test_zero_matrix_edge_cases();
test_large_number_handling();
test_concatenation_errors();
test_mathematical_edge_cases();
test_memory_and_performance_edges();
test_numerical_precision_edges();
test_random_matrix_edge_cases();
test_recovery_after_errors();

print "\n=== ALL MATRIX ERROR HANDLING TESTS PASSED ===";
print "Matrix error handling and edge cases verified successfully!";
