// Test range properties directly to isolate the length calculation issue
// This test focuses on understanding exactly what goes wrong with range objects

print("=== Range Properties Test ===");

print("Testing range object properties to isolate the bug...");

// Test 1: Create range as very first object and test its properties
print("\n--- Test 1: First Range Properties ---");
var first_range = 1..5;
print("First range created: " + first_range);

print("Testing manual indexing of first range:");
print("first_range[0] = " + first_range[0]);
print("first_range[1] = " + first_range[1]);
print("first_range[2] = " + first_range[2]);
print("first_range[3] = " + first_range[3]);

print("Testing foreach on first range:");
var first_count = 0;
foreach (val in first_range) {
    print("First range foreach: " + val);
    first_count = first_count + 1;
}
print("First range foreach count: " + first_count);

// Test 2: Create vector, then range, and test range properties
print("\n--- Test 2: Range After Vector Properties ---");
var test_vector = {10, 20, 30};
print("Vector created: " + test_vector);

var second_range = 1..5;
print("Second range created after vector: " + second_range);

print("Testing manual indexing of second range:");
print("second_range[0] = " + second_range[0]);
print("second_range[1] = " + second_range[1]);
print("second_range[2] = " + second_range[2]);
print("second_range[3] = " + second_range[3]);

print("Testing foreach on second range:");
var second_count = 0;
foreach (val in second_range) {
    print("Second range foreach: " + val);
    second_count = second_count + 1;
}
print("Second range foreach count: " + second_count);

// Test 3: Test different range values after vector
print("\n--- Test 3: Different Range Values After Vector ---");
var range_0_3 = 0..3;
print("Range 0..3 created: " + range_0_3);

var range_0_3_count = 0;
foreach (val in range_0_3) {
    print("Range 0..3 foreach: " + val);
    range_0_3_count = range_0_3_count + 1;
}
print("Range 0..3 count: " + range_0_3_count);

var range_5_8 = 5..8;
print("Range 5..8 created: " + range_5_8);

var range_5_8_count = 0;
foreach (val in range_5_8) {
    print("Range 5..8 foreach: " + val);
    range_5_8_count = range_5_8_count + 1;
}
print("Range 5..8 count: " + range_5_8_count);

// Test 4: Test inclusive ranges
print("\n--- Test 4: Inclusive Range After Vector ---");
var inclusive_range = 1..=5;
print("Inclusive range created: " + inclusive_range);

print("Testing inclusive range manual indexing:");
print("inclusive_range[0] = " + inclusive_range[0]);
print("inclusive_range[1] = " + inclusive_range[1]);
print("inclusive_range[2] = " + inclusive_range[2]);
print("inclusive_range[3] = " + inclusive_range[3]);
print("inclusive_range[4] = " + inclusive_range[4]);

var inclusive_count = 0;
foreach (val in inclusive_range) {
    print("Inclusive foreach: " + val);
    inclusive_count = inclusive_count + 1;
}
print("Inclusive range count: " + inclusive_count);

// Test 5: Test ranges with different starting points
print("\n--- Test 5: Different Starting Points ---");
var neg_range = -2..1;
print("Negative range created: " + neg_range);

var neg_count = 0;
foreach (val in neg_range) {
    print("Negative range foreach: " + val);
    neg_count = neg_count + 1;
}
print("Negative range count: " + neg_count);

// Test 6: Empty ranges
print("\n--- Test 6: Empty Ranges ---");
var empty_range = 5..5;
print("Empty range created: " + empty_range);

var empty_count = 0;
foreach (val in empty_range) {
    print("Empty range foreach: " + val);
    empty_count = empty_count + 1;
}
print("Empty range count: " + empty_count);

// Test 7: Create multiple vectors then ranges
print("\n--- Test 7: Multiple Vectors Then Ranges ---");
var vec1 = {1};
var vec2 = {1, 2};
var vec3 = {1, 2, 3};
print("Created multiple vectors");

var multi_range1 = 10..12;
var multi_range2 = 20..22;
var multi_range3 = 30..32;

var multi_count1 = 0;
foreach (val in multi_range1) {
    multi_count1 = multi_count1 + 1;
}

var multi_count2 = 0;
foreach (val in multi_range2) {
    multi_count2 = multi_count2 + 1;
}

var multi_count3 = 0;
foreach (val in multi_range3) {
    multi_count3 = multi_count3 + 1;
}

print("Multiple range counts: " + multi_count1 + ", " + multi_count2 + ", " + multi_count3);

print("\n=== Results Summary ===");
print("First range (no vector before): " + first_count + "/4");
print("Second range (after vector): " + second_count + "/4");
print("Range 0..3 (after vector): " + range_0_3_count + "/3");
print("Range 5..8 (after vector): " + range_5_8_count + "/3");
print("Inclusive range (after vector): " + inclusive_count + "/5");
print("Negative range: " + neg_count + "/3");
print("Empty range: " + empty_count + "/0");
print("Multiple ranges: " + multi_count1 + "/2, " + multi_count2 + "/2, " + multi_count3 + "/2");

print("\n=== Analysis ===");
if (first_count == 4) {
    print("GOOD: First range works when no vector created before it");
} else {
    print("ISSUE: Even first range fails without vector");
}

if (second_count == 0) {
    print("CONFIRMED: Range fails after vector creation");
} else {
    print("UNEXPECTED: Range works after vector");
}

if (inclusive_count == 5) {
    print("IMPORTANT: Inclusive ranges work correctly after vectors");
    print("This suggests the bug is specific to EXCLUSIVE ranges");
} else {
    print("ISSUE: Inclusive ranges also fail");
}

var all_exclusive_fail = (second_count == 0 and range_0_3_count == 0 and range_5_8_count == 0);
if (all_exclusive_fail) {
    print("PATTERN: ALL exclusive ranges fail after vector creation");
} else {
    print("INCONSISTENT: Some exclusive ranges work, others don't");
}

print("\n=== Range Properties Test Complete ===");
