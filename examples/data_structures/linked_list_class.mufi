// LinkedList class with bounded methods
// This provides an object-oriented interface for linked list operations

class LinkedList {
    // Initialize an empty linked list
    init() {
        self.data = linked_list();
    }

    // Add element to the end of the list
    push(value) {
        push(self.data, value);
        return self;
    }

    // Add multiple elements to the end of the list
    push_many(...values) {
        foreach (val in values) {
            push(self.data, val);
        }
        return self;
    }

    // Add element to the front of the list
    push_front(value) {
        push_front(self.data, value);
        return self;
    }

    // Remove and return element from the end
    pop() {
        return pop(self.data);
    }

    // Remove and return element from the front
    pop_front() {
        return pop_front(self.data);
    }

    // Get element at specific index
    at(index) {
        return nth(self.data, index);
    }

    // Get element at specific index (alias for at)
    nth(index) {
        return nth(self.data, index);
    }

    // Get the number of elements
    length() {
        return len(self.data);
    }

    // Check if list is empty
    is_empty() {
        return len(self.data) == 0;
    }

    // Sort the list in ascending order
    sort() {
        sort(self.data);
        return self;
    }

    // Reverse the list
    reverse() {
        reverse(self.data);
        return self;
    }

    // Search for an element and return its index (-1 if not found)
    search(value) {
        return search(self.data, value);
    }

    // Check if list contains a value
    contains(value) {
        return search(self.data, value) != -1;
    }

    // Clear all elements from the list
    clear() {
        self.data = linked_list();
        return self;
    }

    // Create a copy of the list
    copy() {
        var new_list = LinkedList();
        var i = 0;
        while (i < len(self.data)) {
            push(new_list.data, nth(self.data, i));
            i = i + 1;
        }
        return new_list;
    }

    // Apply a function to each element (map)
    map(func) {
        var new_list = LinkedList();
        var i = 0;
        while (i < len(self.data)) {
            push(new_list.data, func(nth(self.data, i)));
            i = i + 1;
        }
        return new_list;
    }

    // Filter elements based on a predicate function
    filter(predicate) {
        var new_list = LinkedList();
        var i = 0;
        while (i < len(self.data)) {
            var elem = nth(self.data, i);
            if (predicate(elem)) {
                push(new_list.data, elem);
            }
            i = i + 1;
        }
        return new_list;
    }

    // Reduce the list to a single value
    reduce(func, initial) {
        var result = initial;
        var i = 0;
        while (i < len(self.data)) {
            result = func(result, nth(self.data, i));
            i = i + 1;
        }
        return result;
    }

    // Execute a function for each element
    foreach(func) {
        var i = 0;
        while (i < len(self.data)) {
            func(nth(self.data, i));
            i = i + 1;
        }
        return self;
    }

    // Convert to array
    to_array() {
        var arr = array(len(self.data));
        var i = 0;
        while (i < len(self.data)) {
            arr[i] = nth(self.data, i);
            i = i + 1;
        }
        return arr;
    }

    // Get string representation
    to_string() {
        return str(self.data);
    }

    // Print the list
    print() {
        print(self.data);
        return self;
    }
}

// Helper function to create LinkedList from values
fun list_of(...values) {
    var list = LinkedList();
    foreach (val in values) {
        list.push(val);
    }
    return list;
}

// Example usage and tests
fun test_linked_list() {
    print("=== LinkedList Class Tests ===");

    // Test 1: Basic operations
    print("\n[Test 1] Basic operations");
    var list = LinkedList();
    list.push(1).push(2).push(3);
    print("After pushing 1, 2, 3:");
    list.print();

    assert(list.length(), 3);
    assert(list.at(0), 1);
    assert(list.at(1), 2);
    assert(list.at(2), 3);

    // Test 2: Push front and pop operations
    print("\n[Test 2] Push front and pop");
    list.push_front(0);
    print("After push_front(0):");
    list.print();
    assert(list.at(0), 0);

    var popped = list.pop();
    print("Popped: " + str(popped));
    assert(popped, 3);

    var popped_front = list.pop_front();
    print("Popped front: " + str(popped_front));
    assert(popped_front, 0);

    // Test 3: Sort and reverse
    print("\n[Test 3] Sort and reverse");
    var unsorted = list_of(3, 1, 4, 1, 5, 9, 2, 6);
    print("Unsorted:");
    unsorted.print();

    unsorted.sort();
    print("Sorted:");
    unsorted.print();

    unsorted.reverse();
    print("Reversed:");
    unsorted.print();

    // Test 4: Search and contains
    print("\n[Test 4] Search and contains");
    var search_list = list_of("apple", "banana", "cherry", "date");
    var idx = search_list.search("cherry");
    print("Index of 'cherry': " + str(idx));
    assert(idx, 2);

    assert(search_list.contains("banana"), true);
    assert(search_list.contains("grape"), false);

    // Test 5: Map, filter, reduce
    print("\n[Test 5] Functional operations");
    var numbers = list_of(1, 2, 3, 4, 5);

    // Map: square each number
    var squared = numbers.map(fun(x) { return x * x; });
    print("Squared:");
    squared.print();

    // Filter: keep only even numbers
    var evens = numbers.filter(fun(x) { return x % 2 == 0; });
    print("Even numbers:");
    evens.print();

    // Reduce: sum all numbers
    var sum = numbers.reduce(fun(acc, x) { return acc + x; }, 0);
    print("Sum: " + str(sum));
    assert(sum, 15);

    // Test 6: Copy
    print("\n[Test 6] Copy operation");
    var original = list_of("a", "b", "c");
    var copy = original.copy();
    copy.push("d");

    print("Original:");
    original.print();
    print("Copy (with 'd' added):");
    copy.print();

    assert(original.length(), 3);
    assert(copy.length(), 4);

    // Test 7: Chaining operations
    print("\n[Test 7] Method chaining");
    var chain_result = LinkedList()
        .push(5)
        .push(3)
        .push(8)
        .push(1)
        .sort()
        .map(fun(x) { return x * 2; })
        .filter(fun(x) { return x > 4; });

    print("Chained operations result:");
    chain_result.print();

    print("\n=== All tests passed! ===");
}

// Run tests
test_linked_list();
